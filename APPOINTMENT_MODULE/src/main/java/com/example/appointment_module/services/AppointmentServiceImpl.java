package com.example.appointment_module.services;import com.example.appointment_module.domain.Appointment;import com.example.appointment_module.domain.AppointmentDTO;import com.example.appointment_module.repositories.AppointmentRepository;import com.fasterxml.jackson.databind.JsonNode;import com.fasterxml.jackson.databind.JsonSerializable;import com.fasterxml.jackson.databind.node.JsonNodeFactory;import jakarta.persistence.EntityManager;import jakarta.persistence.PersistenceContext;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.cloud.client.ServiceInstance;import org.springframework.cloud.client.discovery.DiscoveryClient;import org.springframework.stereotype.Service;import org.springframework.web.client.RestTemplate;import java.util.HashSet;import java.util.List;import java.util.Optional;import java.util.Set;@Servicepublic class AppointmentServiceImpl implements AppointmentService {    @Autowired    private AppointmentRepository appointmentRepository;    @PersistenceContext    private EntityManager em;    private final DiscoveryClient discoveryClient;    public AppointmentServiceImpl(DiscoveryClient discoveryClient) {        this.discoveryClient = discoveryClient;    }    @Override    public List<Appointment> findAll() {        return (List<Appointment>) appointmentRepository.findAll();    }    @Override    public Optional<Appointment> findById(Long id) {        return appointmentRepository.findById(id);    }    @Override    public Optional<Set<Appointment>> findStartingAppointments() {       // query to find all appointments starting in next minute        Set<Appointment> appointments = new HashSet<>(em.createQuery("SELECT a FROM Appointment a WHERE a.timestamp BETWEEN CURRENT_TIMESTAMP AND CURRENT_TIMESTAMP + 1 MINUTE")                .getResultList());        return Optional.of(appointments);    }    @Override    public Appointment save(Appointment appointment) {        return appointmentRepository.save(appointment);    }    @Override    public Appointment update(Appointment appointment) {        return appointmentRepository.save(appointment);    }    @Override    public void delete(Long id) {        appointmentRepository.deleteById(id);    }    @Override    public Set<Appointment> findByPatientId(Long id) {        return new HashSet<>(em.createQuery("SELECT a FROM Appointment a WHERE a.idPatient = :id")                .setParameter("id", id)                .getResultList());    }    @Override    public Set<Appointment> findByDoctorId(Long id) {        return new HashSet<>(em.createQuery("SELECT a FROM Appointment a WHERE a.idDoctor = :id")                .setParameter("id", id)                .getResultList());    }    @Override    public Optional<AppointmentDTO> findByIdFull(Long id) {        RestTemplate restTemplate = new RestTemplate();        Optional<Appointment> a = appointmentRepository.findById(id);        if(a.isEmpty()){            return Optional.empty();        }        AppointmentDTO dto = new AppointmentDTO();        dto.setId(a.get().getId());        dto.setTimestamp(a.get().getTimestamp());        List<ServiceInstance> serviceInstances = discoveryClient.getInstances("patient");        if (serviceInstances.isEmpty()) {           JsonNode node=  JsonNodeFactory.instance.objectNode().put("error", "Patient service not available");           dto.setPatient(node);           dto.setDoctor(node);           return Optional.of(dto);        }        ServiceInstance serviceInstance = serviceInstances.get(0);        String url = serviceInstance.getUri().toString() + "/patients/" + a.get().getIdPatient();        JsonNode patient = restTemplate.getForObject(url, JsonNode.class);        dto.setPatient(patient);        url = serviceInstance.getUri().toString() + "/doctors/" + a.get().getIdDoctor();        JsonNode doctor = restTemplate.getForObject(url, JsonNode.class);        dto.setDoctor(doctor);        return Optional.of(dto);    }}